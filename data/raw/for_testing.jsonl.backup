{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001000"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001001"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001002"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001003"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001004"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001005"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001006"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001007"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001008"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001009"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001010"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001011"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001012"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001013"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001014"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001015"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001016"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001017"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001018"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001019"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001020"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001021"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001022"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001023"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001024"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001025"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001026"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001027"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001028"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001029"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001030"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001031"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001032"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001033"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001034"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001035"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001036"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001037"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001038"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001039"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001040"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001041"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001042"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001043"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001044"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001045"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001046"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001047"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001048"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001049"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001050"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001051"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001052"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001053"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001054"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001055"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001056"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001057"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001058"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001059"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001060"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001061"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001062"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001063"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001064"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001065"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001066"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001067"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001068"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001069"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001070"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001071"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001072"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001073"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001074"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001075"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001076"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001077"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001078"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001079"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001080"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001081"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001082"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001083"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001084"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001085"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001086"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001087"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001088"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001089"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001090"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001091"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001092"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001093"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001094"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001095"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001096"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001097"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001098"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001099"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001100"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001101"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001102"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001103"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001104"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001105"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001106"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001107"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001108"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001109"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001110"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001111"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001112"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001113"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001114"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001115"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001116"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001117"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001118"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001119"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001120"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001121"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001122"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001123"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001124"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001125"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001126"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001127"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001128"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001129"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001130"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001131"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001132"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001133"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001134"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001135"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001136"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001137"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001138"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001139"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001140"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001141"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001142"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001143"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001144"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001145"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001146"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001147"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001148"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001149"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001150"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001151"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001152"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001153"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001154"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001155"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001156"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001157"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001158"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001159"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001160"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001161"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001162"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001163"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001164"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001165"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001166"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001167"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001168"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001169"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001170"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001171"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001172"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001173"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001174"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001175"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001176"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001177"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001178"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001179"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001180"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001181"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001182"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001183"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001184"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001185"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001186"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001187"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001188"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001189"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001190"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001191"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001192"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001193"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001194"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001195"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001196"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001197"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001198"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001199"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001200"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001201"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001202"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001203"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001204"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001205"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001206"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001207"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001208"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001209"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001210"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001211"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001212"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001213"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001214"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001215"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001216"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001217"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001218"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001219"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001220"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001221"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001222"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001223"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001224"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001225"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001226"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001227"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001228"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001229"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001230"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001231"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001232"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001233"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001234"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001235"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001236"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001237"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001238"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001239"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001240"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001241"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001242"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001243"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001244"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001245"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001246"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001247"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001248"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001249"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001250"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001251"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001252"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001253"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001254"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001255"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001256"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001257"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001258"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001259"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001260"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001261"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001262"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001263"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001264"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001265"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001266"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001267"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001268"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001269"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001270"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001271"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001272"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001273"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001274"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001275"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001276"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001277"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001278"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001279"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001280"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001281"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001282"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001283"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001284"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001285"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001286"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001287"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001288"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001289"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001290"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001291"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001292"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001293"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001294"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001295"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001296"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001297"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001298"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001299"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001300"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001301"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001302"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001303"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001304"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001305"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001306"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001307"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001308"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001309"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001310"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001311"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001312"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001313"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001314"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001315"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001316"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001317"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001318"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001319"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001320"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001321"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001322"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001323"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001324"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001325"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001326"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001327"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001328"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001329"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001330"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001331"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001332"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001333"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001334"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001335"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001336"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001337"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001338"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001339"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001340"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001341"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001342"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001343"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001344"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001345"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001346"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001347"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001348"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001349"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001350"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001351"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001352"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001353"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001354"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001355"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001356"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001357"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001358"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001359"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001360"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001361"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001362"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001363"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001364"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001365"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001366"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001367"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001368"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001369"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001370"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001371"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001372"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001373"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001374"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001375"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001376"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001377"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001378"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001379"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001380"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001381"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001382"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001383"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001384"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001385"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001386"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001387"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001388"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001389"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001390"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001391"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001392"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001393"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001394"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001395"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001396"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001397"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001398"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001399"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001400"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001401"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001402"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001403"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001404"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001405"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001406"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001407"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001408"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001409"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001410"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001411"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001412"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001413"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001414"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001415"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001416"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001417"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001418"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001419"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001420"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001421"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001422"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001423"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001424"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001425"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001426"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001427"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001428"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001429"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001430"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001431"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001432"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001433"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001434"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001435"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001436"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001437"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001438"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001439"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001440"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001441"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001442"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001443"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001444"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001445"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001446"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001447"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001448"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001449"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001450"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001451"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001452"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001453"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001454"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001455"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001456"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001457"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001458"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001459"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001460"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001461"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001462"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001463"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001464"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001465"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001466"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001467"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001468"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001469"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001470"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001471"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001472"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001473"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001474"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001475"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001476"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001477"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001478"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001479"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001480"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001481"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001482"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001483"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001484"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001485"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001486"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001487"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001488"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001489"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001490"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001491"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001492"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001493"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001494"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001495"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001496"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001497"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001498"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001499"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001500"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001501"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001502"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001503"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001504"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001505"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001506"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001507"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001508"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001509"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001510"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001511"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001512"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001513"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001514"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001515"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001516"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001517"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001518"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001519"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001520"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001521"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001522"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001523"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001524"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001525"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001526"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001527"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001528"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001529"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001530"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001531"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001532"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001533"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001534"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001535"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001536"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001537"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001538"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001539"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001540"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001541"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001542"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001543"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001544"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001545"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001546"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001547"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001548"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001549"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001550"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001551"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001552"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001553"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001554"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001555"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001556"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001557"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001558"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001559"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001560"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001561"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001562"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001563"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001564"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001565"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001566"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001567"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001568"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001569"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001570"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001571"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001572"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001573"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001574"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001575"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001576"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001577"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001578"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001579"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001580"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001581"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001582"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001583"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001584"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001585"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001586"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001587"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001588"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001589"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001590"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001591"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001592"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001593"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001594"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001595"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001596"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001597"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001598"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001599"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001600"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001601"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001602"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001603"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001604"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001605"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001606"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001607"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001608"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001609"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001610"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001611"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001612"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001613"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001614"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001615"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001616"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001617"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001618"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001619"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001620"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001621"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001622"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001623"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001624"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001625"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001626"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001627"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001628"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001629"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001630"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001631"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001632"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001633"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001634"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001635"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001636"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001637"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001638"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001639"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001640"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001641"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001642"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001643"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001644"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001645"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001646"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001647"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001648"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001649"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001650"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001651"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001652"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001653"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001654"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001655"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001656"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001657"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001658"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001659"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001660"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001661"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001662"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001663"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001664"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001665"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001666"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001667"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001668"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001669"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001670"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001671"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001672"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001673"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001674"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001675"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001676"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001677"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001678"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001679"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001680"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001681"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001682"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001683"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001684"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001685"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001686"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001687"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001688"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001689"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001690"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001691"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001692"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001693"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001694"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001695"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001696"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001697"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001698"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001699"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001700"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001701"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001702"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001703"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001704"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001705"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001706"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001707"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001708"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001709"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001710"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001711"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001712"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001713"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001714"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001715"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001716"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001717"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001718"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001719"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001720"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001721"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001722"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001723"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001724"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001725"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001726"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001727"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001728"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001729"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001730"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001731"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001732"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001733"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001734"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001735"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001736"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001737"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001738"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001739"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001740"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001741"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001742"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001743"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001744"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001745"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001746"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001747"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001748"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001749"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001750"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001751"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001752"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001753"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001754"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001755"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001756"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001757"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001758"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001759"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001760"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001761"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001762"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001763"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001764"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001765"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001766"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001767"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001768"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001769"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001770"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001771"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001772"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001773"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001774"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001775"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001776"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001777"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001778"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001779"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001780"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001781"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001782"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001783"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001784"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001785"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001786"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001787"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001788"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001789"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001790"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001791"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001792"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001793"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001794"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001795"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001796"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001797"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001798"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001799"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001800"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001801"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001802"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001803"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001804"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001805"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001806"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001807"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001808"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001809"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001810"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001811"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001812"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001813"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001814"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001815"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001816"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001817"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001818"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001819"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001820"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001821"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001822"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001823"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001824"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001825"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001826"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001827"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001828"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001829"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001830"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001831"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001832"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001833"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001834"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001835"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001836"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001837"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001838"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001839"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001840"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001841"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001842"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001843"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001844"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001845"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001846"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001847"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001848"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001849"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001850"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001851"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001852"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001853"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001854"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001855"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001856"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001857"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001858"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001859"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001860"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001861"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001862"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001863"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001864"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001865"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001866"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001867"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001868"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001869"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001870"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001871"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001872"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001873"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001874"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001875"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001876"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001877"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001878"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001879"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001880"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001881"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001882"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001883"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001884"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001885"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001886"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001887"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001888"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001889"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001890"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001891"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001892"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001893"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001894"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001895"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001896"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001897"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001898"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001899"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001900"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001901"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001902"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001903"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001904"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001905"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001906"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001907"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001908"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001909"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001910"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001911"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001912"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001913"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001914"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001915"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001916"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001917"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001918"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001919"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001920"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001921"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001922"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001923"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001924"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001925"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001926"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001927"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001928"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001929"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001930"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001931"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001932"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001933"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001934"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001935"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001936"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001937"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001938"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001939"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001940"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001941"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001942"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001943"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001944"}
{"user": {"mode": "write_sql", "natural_language_task": "List all films with their category and the total number of rentals for each.", "current_schema": "CREATE TABLE film (film_id integer PRIMARY KEY, title varchar); CREATE TABLE film_category (film_id integer REFERENCES film, category_id integer); CREATE TABLE category (category_id integer PRIMARY KEY, name varchar); CREATE TABLE inventory (inventory_id integer PRIMARY KEY, film_id integer REFERENCES film); CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer REFERENCES inventory);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["write_sql"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Retrieve films with category and rental counts", "sql": "SELECT f.title, c.name AS category, COUNT(r.rental_id) AS total_rentals FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, c.category_id ORDER BY total_rentals DESC;"}], "error_explanations": [], "explanations": ["Join film to category via film_category, then to rentals via inventory. Use LEFT JOIN and GROUP BY to count rentals per film."], "safe_to_execute": true}, "id": "gen_001945"}
{"user": {"mode": "optimize_query", "natural_language_task": "Optimize this query for better performance.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT f.title, COUNT(r.rental_id) FROM film f, inventory i, rental r WHERE f.film_id = i.film_id AND i.inventory_id = r.inventory_id GROUP BY f.film_id;", "explain_analyze": ""}, "error_message": ""}, "assistant": {"actions": ["optimize_query"], "migrations": [], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_inventory_film_id ON inventory(film_id);"}, {"sql": "CREATE INDEX idx_rental_inventory_id ON rental(inventory_id);"}], "queries": [{"description": "Optimized rental count query", "sql": "SELECT f.title, COUNT(r.rental_id) FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title;"}], "error_explanations": [], "explanations": ["Replace implicit JOIN with explicit JOIN for clarity. Add indexes on foreign keys to speed up joins."], "safe_to_execute": true}, "id": "gen_001946"}
{"user": {"mode": "fix_error", "natural_language_task": "Fix column name error.", "current_schema": "", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {"problem_query": "SELECT c.first_name, c.last_nme, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;", "explain_analyze": ""}, "error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ..."}, "assistant": {"actions": ["fix_error"], "migrations": [], "rls_policies": [], "indexes": [], "queries": [{"description": "Correct column name", "sql": "SELECT c.first_name, c.last_name, SUM(p.amount) FROM customer c JOIN payment p ON c.customer_id = p.customer_id GROUP BY c.customer_id;"}], "error_explanations": [{"error_message": "ERROR:  column c.last_nme does not exist\\nLINE 1: ...lect c.first_name, c.last_nme, SUM(p.amount) FROM customer c ...", "cause": "Typo in column name 'last_nme' instead of 'last_name'", "fix": "Change 'last_nme' to 'last_name'"}], "explanations": [], "safe_to_execute": true}, "id": "gen_001947"}
{"user": {"mode": "design_schema", "natural_language_task": "Add a loyalty points system for customers.", "current_schema": "CREATE TABLE customer (customer_id integer PRIMARY KEY, first_name varchar, last_name varchar);", "preferences": {"db_engine": "postgres", "naming": "snake_case", "supabase_style": false}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_schema"], "migrations": [{"filename": "001_add_loyalty_points_table.sql", "sql": "CREATE TABLE loyalty_points (id SERIAL PRIMARY KEY, customer_id integer REFERENCES customer(customer_id), points integer DEFAULT 0, earned_date date DEFAULT CURRENT_DATE);"}], "rls_policies": [], "indexes": [{"sql": "CREATE INDEX idx_loyalty_customer_id ON loyalty_points(customer_id);"}], "queries": [{"description": "Award loyalty points for rentals", "sql": "INSERT INTO loyalty_points (customer_id, points) SELECT r.customer_id, COUNT(*) * 10 FROM rental r WHERE r.return_date IS NOT NULL AND r.return_date >= CURRENT_DATE - INTERVAL '1 month' GROUP BY r.customer_id;"}], "error_explanations": [], "explanations": ["Add points table linked to customers, with example query to award based on recent rentals."], "safe_to_execute": true}, "id": "gen_001948"}
{"user": {"mode": "design_rls", "natural_language_task": "Staff should only see rentals from their own store.", "current_schema": "CREATE TABLE rental (rental_id integer PRIMARY KEY, inventory_id integer); CREATE TABLE staff (staff_id integer PRIMARY KEY, store_id integer);", "preferences": {"db_engine": "supabase", "supabase_style": true}, "sql_snippets": {}, "error_message": ""}, "assistant": {"actions": ["design_rls"], "migrations": [], "rls_policies": [{"on_table": "rental", "policy_name": "staff_store_isolation", "sql": "CREATE POLICY staff_store_isolation ON rental FOR ALL USING (inventory_id IN (SELECT inventory_id FROM inventory WHERE store_id = (SELECT store_id FROM staff WHERE staff_id = auth.uid())));"}], "indexes": [], "queries": [], "error_explanations": [], "explanations": ["Use RLS to restrict rentals to those in staff's store via inventory."], "safe_to_execute": true}, "id": "gen_001949"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List all active services for a specific tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY, name text); CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), name text, is_active boolean DEFAULT true);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active services by tenant\", \"sql\": \"SELECT service_id, name FROM service WHERE tenant_id = $1 AND is_active = true ORDER BY name;\"}], \"error_explanations\": [], \"explanations\": [\"Filter services by active status and tenant\"], \"safe_to_execute\": true}", "id": "gen_001950"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find upcoming bookings for the next 7 days for a tenant\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), starts_at timestamptz, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Upcoming bookings within 7 days\", \"sql\": \"SELECT b.booking_id, u.full_name, b.starts_at FROM booking b JOIN app_user u ON b.customer_id = u.user_id WHERE b.tenant_id = $1 AND b.starts_at BETWEEN now() AND now() + interval '7 days' AND b.status = 'confirmed' ORDER BY b.starts_at;\"}], \"error_explanations\": [], \"explanations\": [\"Date range filter on future confirmed bookings\"], \"safe_to_execute\": true}", "id": "gen_001951"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Calculate total revenue per service for the last month\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), status text); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), status text, created_at timestamptz);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Monthly revenue by service\", \"sql\": \"SELECT s.name AS service_name, SUM(p.amount) AS total_revenue FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND p.created_at >= date_trunc('month', now() - interval '1 month') AND p.created_at < date_trunc('month', now()) GROUP BY s.service_id, s.name ORDER BY total_revenue DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Join services, bookings, payments with monthly date filter\"], \"safe_to_execute\": true}", "id": "gen_001952"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List rental orders that have overdue items\", \"current_schema\": \"CREATE TABLE rental_order (rental_order_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), status text, event_date date); CREATE TABLE rental_order_item (rental_order_item_id uuid PRIMARY KEY, rental_order_id uuid REFERENCES rental_order(rental_order_id), rental_end_date date); CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Overdue rental orders\", \"sql\": \"SELECT o.rental_order_id, u.full_name, o.event_date FROM rental_order o JOIN app_user u ON o.customer_id = u.user_id WHERE o.status = 'confirmed' AND EXISTS (SELECT 1 FROM rental_order_item i WHERE i.rental_order_id = o.rental_order_id AND i.rental_end_date < CURRENT_DATE) ORDER BY o.event_date;\"}], \"error_explanations\": [], \"explanations\": [\"Check for items where end date has passed\"], \"safe_to_execute\": true}", "id": "gen_001953"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show resource utilization rate (hours booked / total available hours)\", \"current_schema\": \"CREATE TABLE resource (resource_id uuid PRIMARY KEY, name text, capacity integer); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), start_time timestamptz, end_time timestamptz); CREATE TABLE booking (booking_id uuid PRIMARY KEY, resource_id uuid REFERENCES resource(resource_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Resource utilization rates\", \"sql\": \"SELECT r.name, r.capacity, COUNT(b.booking_id) AS bookings, SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) AS booked_hours, SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600) AS total_available_hours, (SUM(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/3600) / NULLIF(SUM(EXTRACT(epoch FROM (a.end_time - a.start_time))/3600), 0)) * 100 AS utilization_percent FROM resource r LEFT JOIN availability_slot a ON r.resource_id = a.resource_id LEFT JOIN booking b ON r.resource_id = b.resource_id AND b.status = 'confirmed' AND b.starts_at >= CURRENT_DATE AND b.starts_at < CURRENT_DATE + INTERVAL '1 month' GROUP BY r.resource_id, r.name, r.capacity ORDER BY utilization_percent DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Calculate booked hours vs total available hours\"], \"safe_to_execute\": true}", "id": "gen_001954"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List customers who booked more than 3 classes this month\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE service (service_id uuid PRIMARY KEY, service_type text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id), service_id uuid REFERENCES service(service_id), starts_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Active class bookers this month\", \"sql\": \"SELECT u.full_name, u.user_id, COUNT(b.booking_id) AS class_count FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN service s ON b.service_id = s.service_id WHERE s.service_type = 'class' AND b.status = 'confirmed' AND b.starts_at >= date_trunc('month', CURRENT_DATE) GROUP BY u.user_id, u.full_name HAVING COUNT(b.booking_id) > 3 ORDER BY class_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter by class type and count bookings with HAVING clause\"], \"safe_to_execute\": true}", "id": "gen_001955"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find products available for rental in wedding dresses category\", \"current_schema\": \"CREATE TABLE product (product_id uuid PRIMARY KEY, category text, is_active boolean); CREATE TABLE product_inventory (inventory_id uuid PRIMARY KEY, product_id uuid REFERENCES product(product_id), is_available boolean);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Available wedding dresses\", \"sql\": \"SELECT DISTINCT p.product_id, i.inventory_id FROM product p JOIN product_inventory i ON p.product_id = i.product_id WHERE p.category = 'wedding_dress' AND p.is_active = true AND i.is_available = true;\"}], \"error_explanations\": [], \"explanations\": [\"Join products to inventory with category andavailability filters\"], \"safe_to_execute\": true}", "id": "gen_001956"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Show pending payments for a customer\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), amount numeric(12,2), currency char(3), status text);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Pending customer payments\", \"sql\": \"SELECT p.amount, p.currency, p.created_at FROM payment p JOIN booking b ON p.booking_id = b.booking_id WHERE b.customer_id = $1 AND p.status = 'pending' ORDER BY p.created_at DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Filter payments by status and customer\"], \"safe_to_execute\": true}", "id": "gen_001957"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"List services with their average booking duration\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, name text, duration_minutes integer); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), starts_at timestamptz, ends_at timestamptz, status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Average booking duration by service\", \"sql\": \"SELECT s.name, s.duration_minutes AS configured_duration, AVG(EXTRACT(epoch FROM (b.ends_at - b.starts_at))/60) AS average_booked_duration FROM service s LEFT JOIN booking b ON s.service_id = b.service_id AND b.status = 'completed' GROUP BY s.service_id, s.name, s.duration_minutes ORDER BY average_booked_duration;\"}], \"error_explanations\": [], \"explanations\": [\"Average actual vs configured service duration\"], \"safe_to_execute\": true}", "id": "gen_001958"}
{"user": "{\"mode\": \"write_sql\", \"natural_language_task\": \"Find staff members handling the most bookings\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, full_name text, role text); CREATE TABLE booking (booking_id uuid PRIMARY KEY, staff_id uuid REFERENCES app_user(user_id), status text);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"write_sql\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Booking counts by staff\", \"sql\": \"SELECT u.full_name, u.role, COUNT(b.booking_id) AS booking_count FROM app_user u LEFT JOIN booking b ON u.user_id = b.staff_id AND b.status IN ('confirmed', 'completed') WHERE u.role = 'staff' GROUP BY u.user_id, u.full_name, u.role ORDER BY booking_count DESC;\"}], \"error_explanations\": [], \"explanations\": [\"Count confirmed and completed bookings by staff\"], \"safe_to_execute\": true}", "id": "gen_001959"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this slow booking search query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM booking WHERE starts_at > '2024-01-01' AND status = 'confirmed';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add compound index on date filter and status columns\"], \"safe_to_execute\": true}", "id": "gen_001960"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up customer payment lookup\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, SUM(p.amount) FROM app_user u JOIN booking b ON u.user_id = b.customer_id JOIN payment p ON b.booking_id = p.booking_id WHERE u.email = 'customer@example.com' AND p.status = 'paid' GROUP BY u.user_id, u.full_name;\", \"explain_analyze\": \"Seq Scan on app_user (cost=0.00..8.00 rows=1 width=100) (actual time=0.010..0.012 rows=1 loops=1)\\n  Filter: (email = 'customer@example.com'::text)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE UNIQUE INDEX idx_user_email ON app_user(email);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add unique email index for lookups, compound index for payment filtering\"], \"safe_to_execute\": true}", "id": "gen_001961"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Make this product search faster\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM product WHERE category = 'wedding_dress' AND is_active = true;\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_product_category_active ON product(category, is_active);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Compound index for category and active filter\"], \"safe_to_execute\": true}", "id": "gen_001962"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Optimize this rental availability check\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT i.inventory_id FROM product_inventory i WHERE i.is_available = true AND i.product_id = '123e4567-e89b-12d3-a456-426614174000';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_inventory_product_available ON product_inventory(product_id, is_available);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Index on product_id and available flag for quick lookups\"], \"safe_to_execute\": true}", "id": "gen_001963"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Improve this complex service booker query\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC;\", \"explain_analyze\": \"HashAggregate (cost=1000.00..1005.00 rows=10 width=40) (actual time=50.000..50.050 rows=5 loops=1)\\n  Group Key: s.service_id, s.name\\n  ->  Hash Join (cost=500.00..999.00 rows=200 width=80) (actual time=40.000..49.500 rows=120 loops=1)\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_service_starts ON booking(service_id, starts_at);\"}, {\"sql\": \"CREATE INDEX idx_payment_booking_status ON payment(booking_id, status);\"}], \"queries\": [{\"description\": \"Optimized service popularity query\", \"sql\": \"SELECT s.name, COUNT(b.booking_id) FROM service s JOIN booking b ON s.service_id = b.service_id JOIN payment p ON b.booking_id = p.booking_id WHERE p.status = 'paid' AND b.starts_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY s.service_id, s.name ORDER BY COUNT(b.booking_id) DESC LIMIT 10;\"}], \"error_explanations\": [], \"explanations\": [\"Add indexes on join columns, LIMIT results to avoid over-processing\"], \"safe_to_execute\": true}", "id": "gen_001964"}
{"user": "{\"mode\": \"optimize_query\", \"natural_language_task\": \"Speed up tenant data queries\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT COUNT(*) FROM booking WHERE tenant_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"optimize_query\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_booking_tenant ON booking(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_service_tenant ON service(tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_resource_tenant ON resource(tenant_id);\"}], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Add tenant_id indexes for multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001965"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix this GROUP BY error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id;\"}, \"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\\nLINE 1: SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT J...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Fixed GROUP BY query\", \"sql\": \"SELECT u.full_name, COUNT(b.booking_id) FROM app_user u LEFT JOIN booking b ON u.user_id = b.customer_id GROUP BY u.user_id, u.full_name;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  column \\\"u.full_name\\\" must appear in the GROUP BY clause or be used in an aggregate function\", \"cause\": \"Non-aggregated column in SELECT not included in GROUP BY\", \"fix\": \"Add u.full_name to GROUP BY clause\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001966"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Use correct function name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}, \"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\\nLINE 1: ...booking_id, IFNULL(payment_id, 'Unpaid') FROM booking LEFT JO...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use COALESCE instead of IFNULL\", \"sql\": \"SELECT booking_id, COALESCE(payment_id, 'Unpaid') FROM booking LEFT JOIN payment ON booking.booking_id = payment.booking_id;\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  function ifnull(unknown, unknown) does not exist\", \"cause\": \"IFNULL is MySQL syntax, not PostgreSQL\", \"fix\": \"Use COALESCE for PostgreSQL null handling\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001967"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix invalid enum value\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"UPDATE booking SET status = 'approved' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}, \"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\\nDETAIL:  Failing row contains (approved)\\\" marked invalid.\\nLINE 1: UPDATE booking SET status = 'approved' WHERE booking_id = '123...\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use valid status value\", \"sql\": \"UPDATE booking SET status = 'confirmed' WHERE booking_id = '12345678-1234-1234-1234-123456789abc';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  new row for relation \\\"booking\\\" violates check constraint \\\"booking_status_check\\\"\", \"cause\": \"'approved' is not a valid status enum value\", \"fix\": \"Use 'confirmed' which is an allowed status\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001968"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix foreign key violation\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', 'invalid-uuid', 'some-service-id');\"}, \"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\\n DETAIL:  Key (tenant_id)=(invalid-uuid) is not present in table \\\"tenant\\\".\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use existing tenant_id\", \"sql\": \"INSERT INTO booking (booking_id, tenant_id, service_id) VALUES ('12345678-1234-1234-1234-123456789abc', (SELECT tenant_id FROM tenant LIMIT 1), 'some-service-id');\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  insert or update on table \\\"booking\\\" violates foreign key constraint \\\"booking_tenant_id_fkey\\\"\", \"cause\": \"Parent record (tenant) with invalid UUID does not exist\", \"fix\": \"Use an existing tenant_id from the database\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001969"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix date format error\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024/01/01 10:00 AM');\"}, \"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\\nHINT:  Perhaps you need a different \\\"datestyle\\\" setting.\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use ISO date format\", \"sql\": \"INSERT INTO availability_slot (slot_id, start_time) VALUES ('12345678-1234-1234-1234-123456789abc', '2024-01-01 10:00:00'::timestamp);\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  date/time field value out of range: \\\"2024/01/01 10:00 AM\\\"\", \"cause\": \"Date format not recognized by PostgreSQL\", \"fix\": \"Use ISO format: '2024-01-01 10:00:00'\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001970"}
{"user": "{\"mode\": \"fix_error\", \"natural_language_task\": \"Fix wrong table name\", \"current_schema\": \"\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {\"problem_query\": \"SELECT * FROM users WHERE email = 'test@example.com';\"}, \"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\\nLINE 1: SELECT * FROM users WHERE email = 'test@example.com';\"}", "assistant": "{\"actions\": [\"fix_error\"], \"migrations\": [], \"rls_policies\": [], \"indexes\": [], \"queries\": [{\"description\": \"Use correct table name\", \"sql\": \"SELECT * FROM app_user WHERE email = 'test@example.com';\"}], \"error_explanations\": [{\"error_message\": \"ERROR:  relation \\\"users\\\" does not exist\", \"cause\": \"Wrong table name 'users'\", \"fix\": \"Use 'app_user' which is the actual table name\"}], \"explanations\": [], \"safe_to_execute\": true}", "id": "gen_001971"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add a waitlist feature for fully booked services\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE availability_slot (slot_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), tenant_id uuid);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"001_add_waitlist_table.sql\", \"sql\": \"CREATE TABLE waitlist (waitlist_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id), requested_date date DEFAULT CURRENT_DATE, status text CHECK (status IN ('waiting', 'notified', 'cancelled')), created_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_waitlist_service_tenant ON waitlist(service_id, tenant_id);\"}, {\"sql\": \"CREATE INDEX idx_waitlist_customer ON waitlist(customer_id);\"}], \"queries\": [{\"description\": \"Add user to waitlist\", \"sql\": \"INSERT INTO waitlist (tenant_id, service_id, customer_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING;\"}], \"error_explanations\": [], \"explanations\": [\"Add waitlist table linked to services and customers\"], \"safe_to_execute\": true}", "id": "gen_001972"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add customer loyalty points system\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id)); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (payment_id uuid PRIMARY KEY, amount numeric(12,2));\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"002_add_loyalty_points.sql\", \"sql\": \"CREATE TABLE loyalty_points (loyalty_id SERIAL PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), customer_id uuid REFERENCES app_user(user_id), points_earned integer DEFAULT 0, points_spent integer DEFAULT 0, expiry_date date DEFAULT (CURRENT_DATE + INTERVAL '1 year'), created_at timestamptz DEFAULT now()); ALTER TABLE booking ADD COLUMN points_awarded boolean DEFAULT false;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_loyalty_customer ON loyalty_points(customer_id);\"}], \"queries\": [{\"description\": \"Award points for completed booking\", \"sql\": \"INSERT INTO loyalty_points (tenant_id, customer_id, points_earned) SELECT b.tenant_id, b.customer_id, FLOOR(p.amount / 10) FROM booking b JOIN payment p ON b.booking_id = p.booking_id WHERE b.status = 'completed' AND b.points_awarded = false; UPDATE booking SET points_awarded = true WHERE booking_id IN (SELECT booking_id FROM booking WHERE status = 'completed' AND points_awarded = false);\"}], \"error_explanations\": [], \"explanations\": [\"Add loyalty table and track points per customer\"], \"safe_to_execute\": true}", "id": "gen_001973"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add coupon/discount feature\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, base_price numeric(12,2), tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"003_add_coupons.sql\", \"sql\": \"CREATE TABLE coupon (coupon_id uuid PRIMARY KEY, tenant_id uuid REFERENCES tenant(tenant_id), code text UNIQUE, discount_type text CHECK (discount_type IN ('percentage', 'fixed')), discount_value numeric(12,2), valid_from date DEFAULT CURRENT_DATE, valid_until date, max_uses integer, uses_count integer DEFAULT 0, is_active boolean DEFAULT true); ALTER TABLE booking ADD COLUMN coupon_id uuid REFERENCES coupon(coupon_id);\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_coupon_code ON coupon(code);\"}], \"queries\": [{\"description\": \"Apply coupon validation\", \"sql\": \"UPDATE coupon SET uses_count = uses_count + 1 WHERE coupon_id = $1 AND is_active = true AND CURRENT_DATE BETWEEN valid_from AND valid_until AND (max_uses IS NULL OR uses_count < max_uses);\"}], \"error_explanations\": [], \"explanations\": [\"Add flexible discount system with usage tracking\"], \"safe_to_execute\": true}", "id": "gen_001974"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add audit log for booking changes\", \"current_schema\": \"CREATE TABLE booking (booking_id uuid PRIMARY KEY, tenant_id uuid, status text); CREATE TABLE app_user (user_id uuid PRIMARY KEY);\", \"preferences\": {\"db_engine\": \"postgres\", \"naming\": \"snake_case\", \"supabase_style\": false}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"004_add_audit_log.sql\", \"sql\": \"CREATE TABLE booking_audit (audit_id SERIAL PRIMARY KEY, booking_id uuid REFERENCES booking(booking_id), tenant_id uuid, changed_by_user_id uuid REFERENCES app_user(user_id), old_status text, new_status text, change_reason text, changed_at timestamptz DEFAULT now());\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_audit_booking ON booking_audit(booking_id);\"}, {\"sql\": \"CREATE INDEX idx_audit_tenant_time ON booking_audit(tenant_id, changed_at);\"}], \"queries\": [{\"description\": \"Log status change\", \"sql\": \"INSERT INTO booking_audit (booking_id, tenant_id, changed_by_user_id, old_status, new_status, change_reason) VALUES ($1, $2, $3, (SELECT status FROM booking WHERE booking_id = $1), $4, $5);\"}], \"error_explanations\": [], \"explanations\": [\"Audit table tracks all booking status changes\"], \"safe_to_execute\": true}", "id": "gen_001975"}
{"user": "{\"mode\": \"design_schema\", \"natural_language_task\": \"Add service reviews and ratings\", \"current_schema\": \"CREATE TABLE service (service_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE app_user (user_id uuid PRIMARY KEY, tenant_id uuid); CREATE TABLE booking (booking_id uuid PRIMARY KEY, service_id uuid REFERENCES service(service_id), customer_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_schema\"], \"migrations\": [{\"filename\": \"005_add_reviews_and_ratings.sql\", \"sql\": \"CREATE TABLE service_review (review_id uuid PRIMARY KEY DEFAULT gen_random_uuid(), service_id uuid REFERENCES service(service_id), tenant_id uuid NOT NULL, customer_id uuid REFERENCES app_user(user_id), booking_id uuid REFERENCES booking(booking_id), rating integer CHECK (rating >= 1 AND rating <= 5), title text, comment text, is_public boolean DEFAULT true, created_at timestamptz DEFAULT now()); ALTER TABLE service ADD COLUMN avg_rating numeric(2,1) DEFAULT 0, ADD COLUMN review_count integer DEFAULT 0;\"}], \"rls_policies\": [], \"indexes\": [{\"sql\": \"CREATE INDEX idx_review_service_rating ON service_review(service_id, rating);\"}, {\"sql\": \"CREATE INDEX idx_review_customer ON service_review(customer_id);\"}], \"queries\": [{\"description\": \"Calculate average rating\", \"sql\": \"UPDATE service SET avg_rating = (SELECT AVG(rating) FROM service_review WHERE service_id = $1 AND is_public = true), review_count = (SELECT COUNT(*) FROM service_review WHERE service_id = $1) WHERE service_id = $1;\"}], \"error_explanations\": [], \"explanations\": [\"Add review system with rating calculations\"], \"safe_to_execute\": true}", "id": "gen_001976"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Tenants should only see their own data\", \"current_schema\": \"CREATE TABLE tenant (tenant_id uuid PRIMARY KEY); CREATE TABLE service (tenant_id uuid REFERENCES tenant); CREATE TABLE booking (tenant_id uuid REFERENCES tenant);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"tenant\", \"policy_name\": \"tenant_self_read\", \"sql\": \"CREATE POLICY tenant_self_read ON tenant FOR SELECT USING (tenant_id = auth.uid());\"}, {\"on_table\": \"service\", \"policy_name\": \"service_tenant_isolation\", \"sql\": \"CREATE POLICY service_tenant_isolation ON service FOR ALL USING (tenant_id = auth.uid());\"}, {\"on_table\": \"booking\", \"policy_name\": \"booking_tenant_isolation\", \"sql\": \"CREATE POLICY booking_tenant_isolation ON booking FOR ALL USING (tenant_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"RLS policies ensure multi-tenant data isolation\"], \"safe_to_execute\": true}", "id": "gen_001977"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Customers can only see their own bookings and payments\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY); CREATE TABLE booking (customer_id uuid REFERENCES app_user(user_id)); CREATE TABLE payment (booking_id uuid);\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"customer_booking_access\", \"sql\": \"CREATE POLICY customer_booking_access ON booking FOR SELECT USING (customer_id = auth.uid());\"}, {\"on_table\": \"payment\", \"policy_name\": \"customer_payment_access\", \"sql\": \"CREATE POLICY customer_payment_access ON payment FOR SELECT USING (booking_id IN (SELECT b.booking_id FROM booking b WHERE b.customer_id = auth.uid()));\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Restrict customers to their own transactional data\"], \"safe_to_execute\": true}", "id": "gen_001978"}
{"user": "{\"mode\": \"design_rls\", \"natural_language_task\": \"Staff can see all data in their tenant, but only modify bookings assigned to them\", \"current_schema\": \"CREATE TABLE app_user (user_id uuid PRIMARY KEY, role text, tenant_id uuid); CREATE TABLE booking (tenant_id uuid, customer_id uuid, staff_id uuid REFERENCES app_user(user_id));\", \"preferences\": {\"db_engine\": \"supabase\", \"naming\": \"snake_case\", \"supabase_style\": true}, \"sql_snippets\": {}, \"error_message\": \"\"}", "assistant": "{\"actions\": [\"design_rls\"], \"migrations\": [], \"rls_policies\": [{\"on_table\": \"booking\", \"policy_name\": \"staff_tenant_read\", \"sql\": \"CREATE POLICY staff_tenant_read ON booking FOR SELECT USING (tenant_id = (SELECT tenant_id FROM app_user WHERE user_id = auth.uid()));\"}, {\"on_table\": \"booking\", \"policy_name\": \"staff_own_write\", \"sql\": \"CREATE POLICY staff_own_write ON booking FOR UPDATE USING (staff_id = auth.uid());\"}], \"indexes\": [], \"queries\": [], \"error_explanations\": [], \"explanations\": [\"Different policies for reading all tenant data vs writing only assigned items\"], \"safe_to_execute\": true}", "id": "gen_001979"}
